{"version":3,"file":"Bsh-lCe-.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../../../../node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/this.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/store.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\nimport { create_text, should_defer_append } from '../operations.js';\nimport { current_batch } from '../../reactivity/batch.js';\n\n// TODO reinstate https://github.com/sveltejs/svelte/pull/15250\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, fn, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {typeof UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\t/** @type {DocumentFragment | null} */\n\tvar offscreen_fragment = null;\n\n\tfunction commit() {\n\t\tif (offscreen_fragment !== null) {\n\t\t\t// remove the anchor\n\t\t\t/** @type {Text} */ (offscreen_fragment.lastChild).remove();\n\n\t\t\tanchor.before(offscreen_fragment);\n\t\t\toffscreen_fragment = null;\n\t\t}\n\n\t\tvar active = condition ? consequent_effect : alternate_effect;\n\t\tvar inactive = condition ? alternate_effect : consequent_effect;\n\n\t\tif (active) {\n\t\t\tresume_effect(active);\n\t\t}\n\n\t\tif (inactive) {\n\t\t\tpause_effect(inactive, () => {\n\t\t\t\tif (condition) {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t} else {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = skip_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tvar defer = should_defer_append();\n\t\tvar target = anchor;\n\n\t\tif (defer) {\n\t\t\toffscreen_fragment = document.createDocumentFragment();\n\t\t\toffscreen_fragment.append((target = create_text()));\n\t\t}\n\n\t\tif (condition) {\n\t\t\tconsequent_effect ??= fn && branch(() => fn(target));\n\t\t} else {\n\t\t\talternate_effect ??= fn && branch(() => fn(target));\n\t\t}\n\n\t\tif (defer) {\n\t\t\tvar batch = /** @type {Batch} */ (current_batch);\n\n\t\t\tvar active = condition ? consequent_effect : alternate_effect;\n\t\t\tvar inactive = condition ? alternate_effect : consequent_effect;\n\n\t\t\tif (active) batch.skipped_effects.delete(active);\n\t\t\tif (inactive) batch.skipped_effects.add(inactive);\n\n\t\t\tbatch.add_callback(commit);\n\t\t} else {\n\t\t\tcommit();\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { TemplateNode, Dom, Effect } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { current_batch } from '../../reactivity/batch.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\nimport { create_text, should_defer_append } from '../operations.js';\n\n/**\n * @template P\n * @template {(props: P) => void} C\n * @param {TemplateNode} node\n * @param {() => C} get_component\n * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn\n * @returns {void}\n */\nexport function component(node, get_component, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {C} */\n\tvar component;\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\t/** @type {DocumentFragment | null} */\n\tvar offscreen_fragment = null;\n\n\t/** @type {Effect | null} */\n\tvar pending_effect = null;\n\n\tfunction commit() {\n\t\tif (effect) {\n\t\t\tpause_effect(effect);\n\t\t\teffect = null;\n\t\t}\n\n\t\tif (offscreen_fragment) {\n\t\t\t// remove the anchor\n\t\t\t/** @type {Text} */ (offscreen_fragment.lastChild).remove();\n\n\t\t\tanchor.before(offscreen_fragment);\n\t\t\toffscreen_fragment = null;\n\t\t}\n\n\t\teffect = pending_effect;\n\t\tpending_effect = null;\n\t}\n\n\tblock(() => {\n\t\tif (component === (component = get_component())) return;\n\n\t\tvar defer = should_defer_append();\n\n\t\tif (component) {\n\t\t\tvar target = anchor;\n\n\t\t\tif (defer) {\n\t\t\t\toffscreen_fragment = document.createDocumentFragment();\n\t\t\t\toffscreen_fragment.append((target = create_text()));\n\t\t\t\tif (effect) {\n\t\t\t\t\t/** @type {Batch} */ (current_batch).skipped_effects.add(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpending_effect = branch(() => render_fn(target, component));\n\t\t}\n\n\t\tif (defer) {\n\t\t\t/** @type {Batch} */ (current_batch).add_callback(commit);\n\t\t} else {\n\t\t\tcommit();\n\t\t}\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","import { STATE_SYMBOL } from '#client/constants';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\treturn (\n\t\tbound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component\n\t);\n}\n\n/**\n * @param {any} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component = {}, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n\n\treturn element_or_component;\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\nimport { DEV } from 'esm-env';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\tif (DEV) {\n\t\tentry.source.label = store_name;\n\t}\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Effect, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tget,\n\tis_destroying_effect,\n\tset_active_effect,\n\tuntrack\n} from '../runtime.js';\nimport * as e from '../errors.js';\nimport { DESTROYED, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number>, parent_effect: Effect }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\tvar previous_effect = active_effect;\n\n\t\t\ttry {\n\t\t\t\tset_active_effect(target.parent_effect);\n\n\t\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\t\ttarget.special[key] = prop(\n\t\t\t\t\t{\n\t\t\t\t\t\tget [key]() {\n\t\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {string} */ (key),\n\t\t\t\t\tPROPS_IS_UPDATED\n\t\t\t\t);\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t}\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy(\n\t\t{\n\t\t\tprops,\n\t\t\texclude,\n\t\t\tspecial: {},\n\t\t\tversion: source(0),\n\t\t\t// TODO this is only necessary because we need to track component\n\t\t\t// destruction inside `prop`, because of `bind:this`, but it\n\t\t\t// seems likely that we can simplify `bind:this` instead\n\t\t\tparent_effect: /** @type {Effect} */ (active_effect)\n\t\t},\n\t\tlegacy_rest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @type {ProxyHandler<{ props: Array<Record<string | symbol, unknown> | (() => Record<string | symbol, unknown>)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (!p) continue;\n\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\n\t\t\tfor (const key of Object.getOwnPropertySymbols(p)) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\n\tvar get_fallback = () => {\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\n\t\t\tfallback_value = lazy\n\t\t\t\t? untrack(/** @type {() => V} */ (fallback))\n\t\t\t\t: /** @type {V} */ (fallback);\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\t/** @type {((v: V) => void) | undefined} */\n\tvar setter;\n\n\tif (bindable) {\n\t\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t\t// or `createClassComponent(Component, props)`\n\t\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\t\tsetter =\n\t\t\tget_descriptor(props, key)?.set ??\n\t\t\t(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);\n\t}\n\n\tvar initial_value;\n\tvar is_store_sub = false;\n\n\tif (bindable) {\n\t\t[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tinitial_value = /** @type {V} */ (props[key]);\n\t}\n\n\tif (initial_value === undefined && fallback !== undefined) {\n\t\tinitial_value = get_fallback();\n\n\t\tif (setter) {\n\t\t\tif (runes) e.props_invalid_value(key);\n\t\t\tsetter(initial_value);\n\t\t}\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\n\t\t\tif (value !== undefined) {\n\t\t\t\t// in legacy mode, we don't revert to the fallback value\n\t\t\t\t// if the prop goes from defined to undefined. The easiest\n\t\t\t\t// way to model this is to make the fallback undefined\n\t\t\t\t// as soon as the prop has a value\n\t\t\t\tfallback_value = /** @type {V} */ (undefined);\n\t\t\t}\n\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// prop is never written to — we only need a getter\n\tif (runes && (flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// prop is written to, but the parent component had `bind:foo` which\n\t// means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn /** @type {() => V} */ (\n\t\t\tfunction (/** @type {V} */ value, /** @type {boolean} */ mutation) {\n\t\t\t\tif (arguments.length > 0) {\n\t\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t);\n\t}\n\n\t// Either prop is written to, but there's no binding, which means we\n\t// create a derived that we can write to locally.\n\t// Or we are in legacy mode where we always create a derived to replicate that\n\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\tvar overridden = false;\n\n\tvar d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {\n\t\toverridden = false;\n\t\treturn getter();\n\t});\n\n\tif (DEV) {\n\t\td.label = key;\n\t}\n\n\t// Capture the initial value if it's bindable\n\tif (bindable) get(d);\n\n\tvar parent_effect = /** @type {Effect} */ (active_effect);\n\n\treturn /** @type {() => V} */ (\n\t\tfunction (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconst new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;\n\n\t\t\t\tset(d, new_value);\n\t\t\t\toverridden = true;\n\n\t\t\t\tif (fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\t// special case — avoid recalculating the derived if we're in a\n\t\t\t// teardown function and the prop was overridden locally, or the\n\t\t\t// component was already destroyed (this latter part is necessary\n\t\t\t// because `bind:this` can read props after the component has\n\t\t\t// been destroyed. TODO simplify `bind:this`\n\t\t\tif ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {\n\t\t\t\treturn d.v;\n\t\t\t}\n\n\t\t\treturn get(d);\n\t\t}\n\t);\n}\n"],"names":["if_block","node","fn","elseif","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","UNINITIALIZED","flags","EFFECT_TRANSPARENT","has_branch","set_branch","flag","update_branch","offscreen_fragment","commit","active","inactive","resume_effect","pause_effect","new_condition","mismatch","is_else","read_hydration_instruction","HYDRATION_START_ELSE","skip_nodes","set_hydrate_node","set_hydrating","defer","should_defer_append","target","create_text","branch","batch","current_batch","block","hydrate_node","component","get_component","render_fn","effect","pending_effect","is_bound_this","bound_value","element_or_component","STATE_SYMBOL","bind_this","update","get_value","get_parts","old_parts","parts","render_effect","untrack","queue_micro_task","is_store_binding","IS_UNMOUNTED","store_get","store","store_name","stores","entry","mutable_source","noop","is_synchronous_callback","subscribe_to_store","v","set","get_store","get","setup_stores","cleanup","teardown","define_property","capture_store_binding","previous_is_store_binding","spread_props_handler","key","i","p","is_function","value","desc","get_descriptor","descriptor","LEGACY_PROPS","keys","spread_props","props","prop","fallback","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","fallback_value","fallback_dirty","get_fallback","setter","is_entry_props","_a","initial_value","is_store_sub","e.props_invalid_value","getter","PROPS_IS_UPDATED","legacy_parent","mutation","overridden","d","PROPS_IS_IMMUTABLE","derived","derived_safe_equal","parent_effect","active_effect","new_value","proxy","is_destroying_effect","DESTROYED"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}