{"version":3,"file":"start_page.svelte_svelte_type_style_lang.js","sources":["../../../../node_modules/@edwinspire/libopenfusionapigui/dist/OpenFusionAPI/utils.js"],"sourcesContent":["import uFetch from '@edwinspire/universal-fetch';\nimport { writable } from 'svelte/store';\nimport { PUBLIC_API_SERVER_HOST } from '$env/static/public';\n\nconst host = validateBaseUrl(PUBLIC_API_SERVER_HOST || '');\n\nexport const url_paths = {\n\tgetfunctions: host + '/api/system/api/function_names/prd',\n\tgetHandler: host + '/api/system/system/handler/0.01/prd',\n\tMethods: host + '/api/system/system/method/0.01/prd',\n\tlistEnv: host + '/api/system/system/environment/0.01/prd',\n\tlistApps: host + '/api/system/api/apps/0.01/prd',\n\tgetApp: host + '/api/system/api/app/0.01/prd',\n\tsaveApp: host + '/api/system/api/app/0.01/prd',\n\tsaveMethod: host + '/api/system/system/method/0.01/prd',\n\tlogin: host + '/api/system/system/login/0.01/prd',\n\tgetCacheSize: host + '/api/system/cache/response/size/prd',\n\tclearCache: host + '/api/system/cache/clear/prd',\n\tgetUsersList: host + '/api/system/users/list/prd',\n\tgetResponsesCountStatusCode: host + '/api/system/responses/status_code/count/prd',\n\tgetLogs: host + '/api/system/system/log/prd',\n\tgetlistFunctionsVarsJS: host + '/api/system/system/handler/js/funtions/prd',\n\tgetListIntervalTasksByIdApp: host + '/api/system/interval_tasks/byidapp/prd',\n\tupsertIntervalTasksByIdTask: host + '/api/system/interval_tasks/upsert/prd',\n\tdeleteIntervalTasksByIdTask: host + '/api/system/interval_tasks/delete/prd',\n\tserverAPIVersion: host + '/server/version',\n\tapiDoc: host + '/api/system/api/handler/documentation/prd'\n};\n\nexport const userStore = writable({});\nexport const listMethodStore = writable({});\nexport const listHandlerStore = writable({});\nexport const listFunctionStoreDev = writable({});\nexport const listFunctionStoreQA = writable({});\nexport const listFunctionStorePRD = writable({});\nexport const listAppVars = writable({});\nexport const storeCacheSize = writable({});\nexport const storeUsersList = writable({});\nexport const storeCountResponseStatusCode = writable({});\n\nexport const formatJsonForHtmlCode = (/** @type {any} */ json) => {\n\treturn JSON.stringify(json, null, 2).replace(/\\n/g, '<br/>').replace(/ /g, '&nbsp;');\n};\n\nexport const getListUsers = async (/** @type {string} */ token) => {\n\t// @ts-ignore\n\tlet f = new uFetch();\n\tf.setBearerAuthorization(token);\n\ttry {\n\t\tlet users = await f.GET({ url: url_paths.getUsersList });\n\t\tlet data_users = await users.json();\n\n\t\tif (data_users && Array.isArray(data_users)) {\n\t\t\tstoreUsersList.set(data_users);\n\t\t} else {\n\t\t\tstoreUsersList.set([]);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tstoreUsersList.set([]);\n\t}\n};\n\nexport const getListFunction = async (\n\t/** @type {string} */ token,\n\t/** @type {string} */ appName\n) => {\n\t// @ts-ignore\n\tlet f = new uFetch();\n\tf.setBearerAuthorization(token);\n\ttry {\n\t\tlet fr = await f.GET({\n\t\t\turl: url_paths.getfunctions,\n\t\t\tdata: { appName: appName, environment: 'dev' }\n\t\t});\n\t\tlet list = await fr.json();\n\n\t\tif (list && Array.isArray(list)) {\n\t\t\tlet data = list.map((fn) => {\n\t\t\t\treturn { id: fn, value: fn };\n\t\t\t});\n\t\t\tlistFunctionStoreDev.set(data);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tlistFunctionStoreDev.set([]);\n\t}\n\t////////////////////////////////////\n\ttry {\n\t\tlet fr = await f.GET({\n\t\t\turl: url_paths.getfunctions,\n\t\t\tdata: { appName: appName, environment: 'qa' }\n\t\t});\n\t\tlet list = await fr.json();\n\n\t\tif (list && Array.isArray(list)) {\n\t\t\tlet data = list.map((fn) => {\n\t\t\t\treturn { id: fn, value: fn };\n\t\t\t});\n\t\t\tlistFunctionStoreQA.set(data);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tlistFunctionStoreQA.set([]);\n\t}\n\t////////////////////////////////////\n\ttry {\n\t\tlet fr = await f.GET({\n\t\t\turl: url_paths.getfunctions,\n\t\t\tdata: { appName: appName, environment: 'prd' }\n\t\t});\n\t\tlet list = await fr.json();\n\n\t\tif (list && Array.isArray(list)) {\n\t\t\tlet data = list.map((fn) => {\n\t\t\t\treturn { id: fn, value: fn };\n\t\t\t});\n\t\t\tlistFunctionStorePRD.set(data);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tlistFunctionStorePRD.set([]);\n\t}\n};\n\nfunction validateBaseUrl(baseUrl) {\n\ttry {\n\t\t// Intentamos crear una nueva instancia de URL con la baseUrl proporcionada\n\t\tconst url = new URL(baseUrl);\n\n\t\t// Comprobamos si el protocolo es http o https para considerarla válida\n\t\tif (url.protocol === 'http:' || url.protocol === 'https:') {\n\t\t\treturn baseUrl; // Es una base URL válida\n\t\t}\n\t\treturn ''; // Si el protocolo no es válido\n\t} catch (e) {\n\t\t// Si hay un error al crear la URL, consideramos que la URL no es válida\n\t\treturn '';\n\t}\n}\n\nexport const getListHandler = async (/** @type {string} */ token) => {\n\tlet f = new uFetch();\n\tf.setBearerAuthorization(token);\n\ttry {\n\t\tlet fr = await f.GET({ url: url_paths.getHandler });\n\t\tlet list = await fr.json();\n\n\t\tif (list && Array.isArray(list)) {\n\t\t\tlet data = list.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tid: m.handler,\n\t\t\t\t\tvalue: m.label,\n\t\t\t\t\tenabled: m.enabled,\n\t\t\t\t\tdescription: m.description\n\t\t\t\t};\n\t\t\t});\n\t\t\tlistHandlerStore.set(data);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tlistHandlerStore.set([]);\n\t}\n};\n\nexport const getListMethods = async (/** @type {string} */ token) => {\n\tlet f = new uFetch();\n\tf.setBearerAuthorization(token);\n\ttry {\n\t\tlet fr = await f.GET({ url: url_paths.Methods });\n\t\tlet list = await fr.json();\n\n\t\tif (list && Array.isArray(list)) {\n\t\t\tlet data = list.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tid: m.method,\n\t\t\t\t\tvalue: m.label,\n\t\t\t\t\tenabled: m.enabled,\n\t\t\t\t\tdescription: ''\n\t\t\t\t};\n\t\t\t});\n\t\t\tlistMethodStore.set(data);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tlistMethodStore.set([]);\n\t}\n};\n\nexport const getCacheSize = async (app_name, token) => {\n\tlet uf = new uFetch();\n\n\ttry {\n\t\tif (app_name) {\n\t\t\tlet get_list_cache = await uf.GET({\n\t\t\t\turl: url_paths.getCacheSize,\n\t\t\t\tdata: { appName: app_name }\n\t\t\t});\n\n\t\t\tlet cache_list = await get_list_cache.json();\n\t\t\tstoreCacheSize.set(cache_list);\n\t\t}\n\t} catch (error) {\n\t\tconsole.trace(error);\n\t}\n};\n\nexport const defaultValuesIntervalTask = (task) => {\n\tif (task == null) {\n\t\ttask = {\n\t\t\tidtask: undefined,\n\t\t\tidendpoint: undefined,\n\t\t\tname: '',\n\t\t\tdescription: '',\n\t\t\tenabled: false,\n\t\t\tinterval: 3600,\n\t\t\tdatestart: new Date(),\n\t\t\texec_time_limit: 30,\n\t\t\tfailed_attempts: 0,\n\t\t\tstatus: 0\n\t\t};\n\t}\n\n\ttask = {\n\t\tidtask: task.idtask || null,\n\t\tidendpoint: task.idendpoint || null,\n\t\tenabled: task.enabled || false,\n\t\tinterval: task.interval || 3600,\n\t\tdatestart: task.datestart || new Date(),\n\t\texec_time_limit: task.exec_time_limit || 30,\n\t\tfailed_attempts: task.failed_attempts || 0,\n\t\tstatus: task.status || 0\n\t};\n\n\treturn task;\n};\n\nexport const defaultValuesApp = (app) => {\n\tif (app == null) {\n\t\tapp = { app: '', params: { telegram: {} } };\n\t}\n\n\tif (app && app.idapp == null) {\n\t\tapp.idapp = 0;\n\t}\n\n\tif (app && app.app == null) {\n\t\tapp.app = '';\n\t}\n\n\tif (app && app.environment == null) {\n\t\tapp.environment = 'dev';\n\t}\n\n\tif (app && app.description == null) {\n\t\tapp.description = '';\n\t}\n\n\tif (app && app.endpoints == null) {\n\t\tapp.endpoints = [];\n\t}\n\n\tif (app && app.params == null) {\n\t\tapp.params = { telegram: { idgroup: '' } };\n\t}\n\n\tif (app && app.params.telegram == null) {\n\t\tapp.params.telegram = { idgroup: '' };\n\t}\n\n\tif (app && app.params.telegram && app.params.telegram.idgroup == null) {\n\t\tapp.params.telegram.idgroup = '';\n\t}\n\n\tif (app && app.vars == null) {\n\t\tapp.vars = {};\n\t}\n\n\treturn app;\n};\n\nexport const defaultValuesRow = (row) => {\n\tif (row == null) {\n\t\trow = {};\n\t}\n\n\tif (row && row.idendpoint == null) {\n\t\trow.idendpoint = undefined;\n\t}\n\n\tif (row && row.enabled == null) {\n\t\trow.enabled = false;\n\t}\n\n\tif (row && row.access == null) {\n\t\trow.access = 0;\n\t}\n\n\tif (row && row.environment == null) {\n\t\trow.environment = 'dev';\n\t}\n\n\tif (row && row.resource == null) {\n\t\trow.resource = '';\n\t}\n\n\tif (row && row.method == null) {\n\t\trow.method = 'GET';\n\t}\n\n\tif (row && row.handler == null) {\n\t\trow.handler = 'NA';\n\t}\n\n\tif (row && row.cors == null) {\n\t\trow.cors = {};\n\t}\n\n\tif (row && row.code == null) {\n\t\trow.code = '';\n\t}\n\n\tif (row && row.description == null) {\n\t\trow.description = '';\n\t}\n\n\tif (row && row.description == null) {\n\t\trow.description = '';\n\t}\n\n\tif (row && row.headers_test == null) {\n\t\trow.headers_test = {};\n\t}\n\n\tif (row && row.data_test == null) {\n\t\trow.data_test = {};\n\t}\n\n\tif (row && row.rowkey == null) {\n\t\trow.rowkey = 0;\n\t}\n\n\tif (row && row.cache_time == null) {\n\t\trow.cache_time = 0;\n\t}\n\n\tif (row && !row.environment) {\n\t\trow.environment = '?';\n\t}\n\n\tif (row && !row.endpoint) {\n\t\trow.endpoint = '';\n\t}\n\n\tif (row && !row.method) {\n\t\trow.method = '';\n\t}\n\n\tif (row && !row.handler) {\n\t\trow.handler = '';\n\t}\n\tif (row && row.ctrl == null) {\n\t\trow.ctrl = {};\n\t}\n\n\tif (row && row.ctrl.users == null) {\n\t\trow.ctrl.users = [];\n\t}\n\n\tif (row && row.ctrl.log == null) {\n\t\trow.ctrl.log = {};\n\t}\n\n\tif (row && row.data_test == null) {\n\t\trow.data_test = { query: {}, body: {}, headers: {}, auth: {} };\n\t}\n\n\tif (row && row.data_test.query == null) {\n\t\trow.data_test.query = {};\n\t}\n\n\tif (row && row.data_test.body == null) {\n\t\trow.data_test.body = {};\n\t}\n\n\tif (row && row.data_test.headers == null) {\n\t\trow.data_test.headers = {};\n\t}\n\n\tif (row && row.data_test.auth == null) {\n\t\trow.data_test.auth = {};\n\t}\n\n\treturn row;\n};\n\nexport const getCountStatusCode = async (app_name, token) => {\n\tlet uf = new uFetch();\n\t//uf.setBearerAuthorization(token);\n\ttry {\n\t\tif (app_name) {\n\t\t\tlet get_list = await uf.GET({\n\t\t\t\turl: url_paths.getResponsesCountStatusCode,\n\t\t\t\tdata: { appName: app_name }\n\t\t\t});\n\n\t\t\tlet list = await get_list.json();\n\t\t\tstoreCountResponseStatusCode.set(list);\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n};\n\n/**\n * @param {string} string_url\n */\nexport function validateURL(string_url) {\n\tconst patron = /^\\/[a-zA-Z0-9\\-._~%]+(\\/[a-zA-Z0-9\\-._~%]+)*\\/?$/;\n\t// ^ Inicio de la cadena\n\t// \\/ Barra inicial\n\t// [a-zA-Z0-9\\-._~%]+ Uno o más caracteres permitidos en la ruta\n\t// (\\/[a-zA-Z0-9\\-._~%]+)* Cero o más grupos adicionales de barra seguido de caracteres permitidos\n\t// \\/? Barra opcional al final\n\t// $ Fin de la cadena\n\n\tif (patron.test(string_url)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function createEndpoint(method, app, resource, environment) {\n\treturn `${method == 'WS' ? '/ws/' : '/api/'}${app}${resource}/${environment}`;\n}\n\nexport const listAccessMethod = [\n\t{ value: 'Public', id: 0 },\n\t{ value: 'Basic', id: 1 },\n\t{ value: 'Bearer', id: 2 },\n\t{ value: 'Basic & Bearer', id: 3 }\n];\nexport const listHTTPMethods = {\n\tGET: { color: 'primary', icon: 'fa-brands fa-get-pocket' },\n\tPOST: { color: 'link', icon: 'fa-solid fa-signs-post' },\n\tDELETE: { color: 'danger', icon: 'fa-solid fa-trash' },\n\tPUT: { color: 'info', icon: 'fa-solid fa-file-pen' },\n\tWS: { color: 'warning', icon: 'fa-solid fa-tower-broadcast' }\n};\n\nexport const listHandlers = {\n\tJS: { color: 'success', icon: 'fa-brands fa-js', label: 'Javascript' },\n\tSQL: { color: 'link', icon: 'fa-solid fa-database', label: 'SQL' },\n\tSQL_BULK_I: { color: 'danger', icon: 'fa-solid fa-database', label: 'SQL BULK INSERT' },\n\tHANA: { color: '', icon: 'fa-solid fa-database', label: 'Hana' },\n\tFETCH: { color: 'primary', icon: 'fa-solid fa-globe', label: 'Fetch' },\n\tSOAP: { color: 'info', icon: 'fa-solid fa-soap', label: 'SOAP' },\n\tTEXT: { color: 'warning', icon: 'fa-regular fa-file-lines', label: 'Text' },\n\tFUNCTION: { color: 'danger', icon: 'fa-solid fa-robot', label: 'Function' },\n\tMONGODB: { color: '', icon: 'fa-solid fa-database', label: 'MongoDB' },\n\tMCP: { color: 'danger', icon: 'fa-solid fa-plug fa-bounce', label: 'MCP' }\n};\n\nexport const listEnv = {\n\tprd: {\n\t\tcolor: ' has-text-success ',\n\t\tbackground: 'success',\n\t\ticon: ' fa-solid fa-gear fa-spin ',\n\t\tlabel: 'Production'\n\t},\n\tqa: {\n\t\tcolor: ' has-text-warning ',\n\t\tbackground: 'warning',\n\t\ticon: ' fa-solid fa-eye ',\n\t\tlabel: 'Quality'\n\t},\n\tdev: {\n\t\tcolor: ' has-text-danger ',\n\t\tbackground: 'danger',\n\t\ticon: ' fa-solid fa-bug ',\n\t\tlabel: 'Development'\n\t}\n};\n"],"names":[],"mappings":";;AAIa,gBAA0C,EAAE;AAyHzD,SAAS,gBAAgB,SAAS;AACjC,MAAI;AAEH,UAAM,MAAM,IAAI,IAAI,OAAO;AAG3B,QAAI,IAAI,aAAa,WAAW,IAAI,aAAa,UAAU;AAC1D,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR,SAAS,GAAG;AAEX,WAAO;AAAA,EACR;AACD;","x_google_ignoreList":[0]}